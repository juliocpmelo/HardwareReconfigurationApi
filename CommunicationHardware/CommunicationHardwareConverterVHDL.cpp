#include "CommunicationHardwareConverterVHDL.h"

using namespace std;

CommunicationHardwareConverterVHDL::CommunicationHardwareConverterVHDL(){}

void CommunicationHardwareConverterVHDL::buildComponentDescription(std::string componentPath, HardwareComponent* communicationHardwareComponent){
	
	ofstream outFile;
	string fileLocation = string(componentPath);
	cout<<"generating vhdl to component "<<endl;
	outFile.open (fileLocation.c_str());
	
	outFile <<"-- This file was auto generated by the CommunicationHardwareGenerator"<<endl<<endl;
	outFile <<"-- Component Declaration"<<endl<<endl;
	outFile <<"component "<<communicationHardwareComponent->componentInfo->name<<" is"<<endl; //TODO place the main tag name here
	outFile <<"generic ("<<endl;
	std::map<std::string, HardwareComponent::ParamInfo> paramTable = communicationHardwareComponent->componentInfo->componentParameters;

	map<string, HardwareComponent::ParamInfo>::iterator lastParam = paramTable.end();
	lastParam --;
	for(map<string, HardwareComponent::ParamInfo>::iterator it = paramTable.begin(); it != paramTable.end(); it++){
		if (it == lastParam)
			outFile<<"\t"<<translateParam(&(it->second))<<endl;
		else
			outFile<<"\t"<<translateParam(&(it->second))<<";"<<endl;

	}
	outFile <<");"<<endl;

	outFile <<"port ("<<endl;

	std::map<std::string, HardwareComponent::PortInfo*> portsTable = communicationHardwareComponent->ports;

	map<string, HardwareComponent::PortInfo*>::iterator lastElement = portsTable.end();
	lastElement --;
	for(map<string, HardwareComponent::PortInfo*>::iterator it = portsTable.begin(); it != portsTable.end(); it++){
		if (it == lastElement)
			outFile<<"\t"<<translatePort(it->second)<<endl;
		else
			outFile<<"\t"<<translatePort(it->second)<<";"<<endl;

	}
	outFile <<");"<<endl;

	outFile <<"end "<<communicationHardwareComponent->componentInfo->name<<";"<<endl<<endl;

	outFile <<"-- Component Declaration end"<<endl<<endl;

	outFile.close();

}

sc_signal_resolved* CommunicationHardwareConverterVHDL::getSignalToSwInterface(HardwareComponent::PortInfo *swInterface){
	
	sc_signal_resolved *retSignal = new sc_signal_resolved((string(swInterface->name + "_reg")).c_str());
	sc_attribute<HardwareComponent::DataType*> *signalType = new sc_attribute<HardwareComponent::DataType*>( "DataType", swInterface->type);
	retSignal->add_attribute(*signalType);
	
	return retSignal;
}


std::string CommunicationHardwareConverterVHDL::getPadString(int size, int desiredSize){

	int hexPartSize = (desiredSize - size/4)/4;
	
	int binPartSize = (hexPartSize - size%4);

	return "";
	
}


void CommunicationHardwareConverterVHDL::buildEntityForReconfigurableRegion(ReconfigurableRegion *reg, std::string projectPath){

	ofstream outFile;

	HardwareComponent *communicationHardwareComponent = reg->communicationHardware;
	string fileLocation = projectPath + "/CommunicationHardware_" + reg->name + ".vhdl";
	cout<<"generating vhdl to component "<<endl;
	outFile.open (fileLocation.c_str());
	
	outFile <<"-- This file was auto generated by the CommunicationHardwareGenerator"<<endl<<endl;
	outFile <<"-- Entity Declaration"<<endl<<endl;
	outFile <<"entity "<<communicationHardwareComponent->componentInfo->name<<" is"<<endl; //TODO place the main tag name here
	outFile <<"generic ("<<endl;
	std::map<std::string, HardwareComponent::ParamInfo> paramTable = communicationHardwareComponent->componentInfo->componentParameters;

	map<string, HardwareComponent::ParamInfo>::iterator lastParam = paramTable.end();
	lastParam --;
	for(map<string, HardwareComponent::ParamInfo>::iterator it = paramTable.begin(); it != paramTable.end(); it++){
		if (it == lastParam)
			outFile<<"\t"<<translateParam(&(it->second))<<endl;
		else
			outFile<<"\t"<<translateParam(&(it->second))<<";"<<endl;

	}
	outFile <<");"<<endl;

	outFile <<"port ("<<endl;

	std::map<std::string, HardwareComponent::PortInfo*> portsTable = communicationHardwareComponent->ports;

	map<string, HardwareComponent::PortInfo*>::iterator lastElement = portsTable.end();
	lastElement --;
	for(map<string, HardwareComponent::PortInfo*>::iterator it = portsTable.begin(); it != portsTable.end(); it++){
		if (it == lastElement)
			outFile<<"\t"<<translatePort(it->second)<<endl;
		else
			outFile<<"\t"<<translatePort(it->second)<<";"<<endl;

	}
	outFile <<");"<<endl;

	outFile <<"end "<<communicationHardwareComponent->componentInfo->name<<";"<<endl<<endl;

	outFile <<"-- Entity Declaration end"<<endl<<endl;

	outFile<<"architecture arch of "<<communicationHardwareComponent->componentInfo->name<<" is"<<endl;

	outFile <<"-- Register Declaration"<<endl<<endl;
	set<string> swAccessibleInterfaces = reg->assignedTopComponent->softwareAccessiblePorts;
	for(set<string>::iterator it = swAccessibleInterfaces.begin(); it!= swAccessibleInterfaces.end(); it ++){

		HardwareComponent::PortInfo *swAccessibleInterface = reg->assignedTopComponent->ports[*it];

		sc_signal_resolved* convertedSignal = getSignalToSwInterface(swAccessibleInterface);

		outFile<<translateSignal(convertedSignal)<<";"<<endl;
		delete convertedSignal;
	}

	outFile<<"begin"<<endl;

	outFile <<"-- Main Entity Portmap"<<endl<<endl;


	outFile <<"-- Read process from communication hardware"<<endl<<endl;


	outFile <<"readProcess: process(clk)"<<endl<<"begin"<<endl;
	outFile <<"if rising_edge(clk) and mode ='0' then"<<endl;

//	set<string>::iterator lastElement = swAccessibleInterfaces.end();
//	lastElement --;
	int addrCount;
	for(set<string>::iterator it = swAccessibleInterfaces.begin(); it!= swAccessibleInterfaces.end(); it ++){
		HardwareComponent::PortInfo *swAccessibleInterface = reg->assignedTopComponent->ports[*it];


		int commHardwareDataWidth = atoi((communicationHardwareComponent->getParamValue("dataWidth")).c_str());
		int commHardwareAddressWidth = atoi((communicationHardwareComponent->getParamValue("addressWidth")).c_str());

		stringstream addrHex;

		addrHex<<std::hex<<addrCount<<std::dec;

		string paddedAddr = getPadString(addrHex.str().length(),commHardwareAddressWidth);


//		string paddedDataReg = getPadString(swAccessibleInterface->type.length(),commHardwareDataWidth);

//		outFile<<translateSignal(convertedSignal)<<";"<<endl;
		addrCount ++;
	}
	outFile <<"end if;"<<endl;




	outFile <<"end process readProcess;"<<endl;


	
	outFile <<"readProcess: process(clk)"<<endl<<"begin"<<endl;







	outFile<<"end arch;"<<endl;


	outFile.close();



}

void CommunicationHardwareConverterVHDL::buildRegisterSet(HardwareComponent* topComponent){}

void CommunicationHardwareConverterVHDL::buildReadProcess(){}

void CommunicationHardwareConverterVHDL::buildWriteProcess(){}



