###################################################################
##
## Name     : hdmi_out
## Desc     : Microprocessor Peripheral Description
##          : Automatically generated by PsfUtility
##
###################################################################

BEGIN hdmi_out

## Peripheral Options
OPTION IPTYPE = PERIPHERAL
OPTION IMP_NETLIST = TRUE
OPTION HDL = VHDL
OPTION IP_GROUP = MICROBLAZE:PPC:USER
OPTION DESC = HDMI_OUT
OPTION LONG_DESC = Reads video data stored in external memory to an HDMI port
OPTION ARCH_SUPPORT_MAP = (others=DEVELOPMENT)


## Bus Interfaces
BUS_INTERFACE BUS = VFBC_OUT, BUS_STD = XIL_VFBC, BUS_TYPE = INITIATOR

##Parameters
PARAMETER FRAME_BASE_ADDR = 0x00000000, DT = std_logic_vector, ASSIGNMENT = REQUIRE, DESC="FRAME BASE ADDRESS", LONG_DESC="Select the physical address of the framebuffer in memory. This address must be 128 byte alligned (bits 6-0=0) and designate a region within the MPMC space large enough for the frame.
PARAMETER RESOLUTION_SELECT=1, DT=integer, ASSIGNMENT=OPTIONAL, RANGE=(1,3), VALUES=(1=640x480p@60Hz,  3=1280x720p@60Hz), DESC="RESOLUTION", LONG_DESC="Select the output resolution. You must provide a pixel clock with the corresponding frequency: 480p=25MHz 720p=75MHz"
PARAMETER LINE_STRIDE=0x000000, DT=std_logic_vector, ASSIGNMENT=REQUIRE, DESC="LINE STRIDE", LONG_DESC="Select the line stride of the output framebuffer. This is the number of pixels between the start of each line. This number should be greater than or equal to the Frame width. You may use this to allow extra space to exist in memory between where the video data for one line ends and the video data for the next line begins. Must be 128 byte alligned"

## Ports
#PORT CLK_100MHZ_I = "", SIGIS = CLK, DIR = I
PORT PXLCLK_I = "", SIGIS = CLK, DIR = I
PORT PXLCLK_2X_I = "", SIGIS = CLK, DIR = I
PORT PXLCLK_10X_I = "", SIGIS = CLK, DIR = I
PORT LOCKED_I = "", DIR = I
PORT TMDS = "", DIR = O, VEC = [3:0]
PORT TMDSB = "", DIR = O, VEC = [3:0]
# VFBC Cmd Ports
PORT VFBC_CMD_CLK = cmd_clk, DIR = O, BUS = VFBC_OUT
PORT VFBC_CMD_RESET = cmd_reset, DIR = O, BUS = VFBC_OUT
PORT VFBC_CMD_DATA = cmd_data, DIR = O, BUS = VFBC_OUT, VEC = [31:0]
PORT VFBC_CMD_WRITE = cmd_write, DIR = O, BUS = VFBC_OUT
PORT VFBC_CMD_END = cmd_end, DIR = O, BUS = VFBC_OUT
PORT VFBC_CMD_FULL = cmd_full, DIR = I, BUS = VFBC_OUT
PORT VFBC_CMD_ALMOST_FULL = cmd_almost_full, DIR = I, BUS = VFBC_OUT
PORT VFBC_CMD_IDLE = cmd_idle, DIR = I, BUS = VFBC_OUT
# VFBC Read FIFO Ports
PORT VFBC_RD_CLK = rd_clk, DIR = O, BUS = VFBC_OUT
PORT VFBC_RD_RESET = rd_reset, DIR = O, BUS = VFBC_OUT
PORT VFBC_RD_READ = rd_read, DIR = O, BUS = VFBC_OUT
PORT VFBC_RD_END_BURST = rd_end_burst, DIR = O, BUS = VFBC_OUT
PORT VFBC_RD_FLUSH = rd_flush, DIR = O, BUS = VFBC_OUT
PORT VFBC_RD_DATA = rd_data, DIR = I, BUS = VFBC_OUT, VEC = [15:0]
PORT VFBC_RD_EMPTY = rd_empty, DIR = I, BUS = VFBC_OUT
PORT VFBC_RD_ALMOST_EMPTY = rd_almost_empty, DIR = I, BUS = VFBC_OUT

END
