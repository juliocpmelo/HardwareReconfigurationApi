#ifndef HardwareComponent_h
#define HardwareComponent_h

#include <systemc.h>

#include <map>
#include <set>

#define VECTOR_TYPE(indexBegin, indexOp, indexEnd) new HardwareComponent::VectorType(indexBegin, indexEnd, indexOp)

#define BIT_TYPE new HardwareComponent::DataType(HardwareComponent::DataTypeId_bit)

#define INTEGER_TYPE(rangeBegin, rangeOp, rangeEnd)	new HardwareComponent::IntegerType(rangeBegin, rangeEnd, rangeOp)

SC_MODULE(HardwareComponent) {

	typedef enum DataTypeId_t{
		DataTypeId_vector,
		DataTypeId_bit,
		DataTypeId_integer,
		DataTypeId_string
	}DataTypeId;

	class DataType{
		public:
			DataTypeId id;
		public:
			DataType(DataTypeId id){
				this->id = id;
			}
			virtual int size() {if (id == DataTypeId_bit) return 1; else return 0;}
	};

	class VectorType : public DataType{
		public:
			/*
			 * start and end indexes allow vectors
			 * start and end at any index regardness of size
			 * those parameters are required in either vhdl
			 * or verilog
			 */
			std::string startIndex;
			std::string endIndex;

			/*
			 * for vhdl it could be downto and to
			 * for verilog it is not relevant
			 */
			std::string indexOperator;
		public:
			VectorType( std::string startIndex, std::string endIndex, std::string indexOperator) : DataType(DataTypeId_vector){
				this->startIndex = startIndex;
				this->endIndex = endIndex;
				this->indexOperator = indexOperator;
			}
			/*maybe in future it could be used to evaluate expressions in startIndex and endIndex*/
			virtual int size() { 
				if (indexOperator == "to")
					return atoi(endIndex.c_str()) - atoi(startIndex.c_str());
				else
					return atoi(startIndex.c_str()) - atoi(endIndex.c_str());
			}
	};

	class IntegerType : public DataType{
		public:
			/*
			 * start and end ranges are required to languages
			 * in order to limiit the ammount of bytes used
			 * in the representation
			 */
			std::string rangeStart;
			std::string rangeEnd;

			/*
			 * it could be downto and to
			 */
			std::string rangeOperator;
		public:
			IntegerType(std::string rangeStart, std::string rangeEnd, std::string rangeOperator) : DataType(DataTypeId_integer){
				this->rangeStart = rangeStart;
				this->rangeEnd = rangeEnd;
				this->rangeOperator = rangeOperator;
			}

			/*maybe in future it could be used to evaluate expressions in startRange and endRange*/
			virtual int size() { 
				return 32;
			}
	};

	typedef enum PortType_t{
		PortType_in,
		PortType_out,
		PortType_inout
	}PortType;


	typedef struct PortInfo_t{
		std::string name;
		DataType* type;
		PortType portType;
		sc_port_base * scPort;
	}PortInfo;

	typedef struct ParamInfo_t{
		std::string name;
		DataType* type;
		std::string defaultValue;
	}ParamInfo;


/*this information table should be generated by the ComponentDatabase or ComponentLocator*/
	typedef struct HardwareComponentInfo_t{
	/*maybe put here the files and dependencies*/
    std::string name;
    std::map<std::string, PortInfo > inputs;
    std::map<std::string, PortInfo > outputs;

		/*generic name, type, default value*/
    std::map<std::string, ParamInfo > componentParameters;

		/*list of files that need to be compiled in order to get this component corretly synthesised*/
		std::set<std::string> dependencyFiles;
	
		/* file including the declaration of the current component
		 * declaration is used in 
		 * - vhdl: component name begin ... end;
		 * - verilog: `include file
		 * TODO: autogenerate both declaration files from their source code or include
		 * this information in the xml description
		 */
		std::string componentDeclaration;

	}HardwareComponentInfo;


	private:
		void buildComponentPorts();

	public:
		/*specific instance ports*/
		std::map<std::string, PortInfo*> ports;
		std::set<std::string> softwareAccessiblePorts;

		/*specific instance param values*/
		std::map<std::string, std::string> paramValues;
		bool isDynamic;
		HardwareComponentInfo *componentInfo;
		//table containing information about the component
	
	public:
		SC_HAS_PROCESS(HardwareComponent);
		HardwareComponent(sc_module_name name, HardwareComponentInfo *infoTable);
		void createSoftwareAccess(std::string portName);

		/*functions used in dynamic creation*/
		void addInput(std::string name, DataType *type);
		void addOutput(std::string name, DataType *type);
		void addInout(std::string name, DataType *type);
		sc_port_base* getPort(std::string name);
		void portMap(std::string selfPortName, sc_port_base* port);
		void portMap(std::string selfPortName, sc_signal_resolved* signal);
		void addChildObject(sc_object *child);

		std::string getParamValue(std::string paramName);
		void setParamValue(std::string paramName, std::string value);

	private:
		void addPortAttributes(std::string name, DataType *type);

};

#endif
